/** @license ISC License (c) copyright 2016 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

const combinators = {
  applyTo: require('./applyTo'),
  composeB: require('./composeB'),
  constant: require('./constant'),
  flip: require('./flip'),
  identity: require('./identity'),
  reverseApply: require('./reverseApply'),
  substitution: require('./substitution')
}

const crocks = {
  Arrow: require('./Arrow'),
  Async: require('./Async'),
  Const: require('./Const'),
  Either: require('./Either'),
  Identity: require('./Identity'),
  IO: require('./IO'),
  List: require('./List'),
  Maybe: require('./Maybe'),
  Pair: require('./Pair'),
  Pred: require('./Pred'),
  Reader: require('./Reader'),
  Result: require('./Result'),
  Star: require('./Star'),
  State: require('./State'),
  Unit: require('./Unit'),
  Writer: require('./Writer')
}

const helpers = {
  assign: require('./assign'),
  assoc: require('./assoc'),
  binary: require('./binary'),
  branch: require('./branch'),
  compose: require('./compose'),
  composeK: require('./composeK'),
  composeP: require('./composeP'),
  composeS: require('./composeS'),
  curry: require('./curry'),
  defaultProps: require('./defaultProps'),
  defaultTo: require('./defaultTo'),
  dissoc: require('./dissoc'),
  fanout: require('./fanout'),
  fromPairs: require('./fromPairs'),
  liftA2: require('./liftA2'),
  liftA3: require('./liftA3'),
  mconcat: require('./mconcat'),
  mconcatMap: require('./mconcatMap'),
  mreduce: require('./mreduce'),
  mreduceMap: require('./mreduceMap'),
  nAry: require('./nAry'),
  objOf: require('./objOf'),
  omit: require('./omit'),
  once: require('./once'),
  partial: require('./partial'),
  pick: require('./pick'),
  pipe: require('./pipe'),
  pipeK: require('./pipeK'),
  pipeP: require('./pipeP'),
  pipeS: require('./pipeS'),
  prop: require('./prop'),
  propPath: require('./propPath'),
  safe: require('./safe'),
  safeLift: require('./safeLift'),
  tap: require('./tap'),
  toPairs: require('./toPairs'),
  tryCatch: require('./tryCatch'),
  unary: require('./unary'),
  unit: require('./unit')
}

const logic = {
  and: require('./and'),
  ifElse: require('./ifElse'),
  not: require('./not'),
  or: require('./or'),
  unless: require('./unless'),
  when: require('./when')
}

const monoids = {
  All: require('./All'),
  Any: require('./Any'),
  Assign: require('./Assign'),
  Endo: require('./Endo'),
  First: require('./First'),
  Last: require('./Last'),
  Max: require('./Max'),
  Min: require('./Min'),
  Prod: require('./Prod'),
  Sum: require('./Sum'),
}

const pointfree = {
  alt: require('./alt'),
  ap: require('./ap'),
  bimap: require('./bimap'),
  both: require('./both'),
  chain: require('./chain'),
  coalesce: require('./coalesce'),
  concat: require('./concat'),
  cons: require('./cons'),
  contramap: require('./contramap'),
  either: require('./either'),
  empty: require('./empty'),
  evalWith: require('./evalWith'),
  execWith: require('./execWith'),
  extend: require('./extend'),
  filter: require('./filter'),
  first: require('./first'),
  fold: require('./fold'),
  fst: require('./fst'),
  head: require('./head'),
  log: require('./log'),
  map: require('./map'),
  merge: require('./merge'),
  option: require('./option'),
  promap: require('./promap'),
  read: require('./read'),
  reduce: require('./reduce'),
  reject: require('./reject'),
  run: require('./run'),
  runWith: require('./runWith'),
  second: require('./second'),
  sequence: require('./sequence'),
  snd: require('./snd'),
  swap: require('./swap'),
  tail: require('./tail'),
  traverse: require('./traverse'),
  value: require('./value')
}

const predicates = {
  hasProp: require('./hasProp'),
  isAlt: require('./isAlt'),
  isAlternative: require('./isAlternative'),
  isApplicative: require('./isApplicative'),
  isApply: require('./isApply'),
  isArray: require('./isArray'),
  isBifunctor: require('./isBifunctor'),
  isBoolean: require('./isBoolean'),
  isCategory: require('./isCategory'),
  isChain: require('./isChain'),
  isContravariant: require('./isContravariant'),
  isDefined: require('./isDefined'),
  isEmpty: require('./isEmpty'),
  isExtend: require('./isExtend'),
  isFoldable: require('./isFoldable'),
  isFunction: require('./isFunction'),
  isFunctor: require('./isFunctor'),
  isInteger: require('./isInteger'),
  isMonad: require('./isMonad'),
  isMonoid: require('./isMonoid'),
  isNil: require('./isNil'),
  isNumber: require('./isNumber'),
  isObject: require('./isObject'),
  isPlus: require('./isPlus'),
  isProfunctor: require('./isProfunctor'),
  isPromise: require('./isPromise'),
  isSameType: require('./isSameType'),
  isSemigroup: require('./isSemigroup'),
  isSemigroupoid: require('./isSemigroupoid'),
  isSetoid: require('./isSetoid'),
  isString: require('./isString'),
  isTraversable: require('./isTraversable')
}

const transforms = {
  arrayToList: require('./arrayToList'),
  eitherToAsync: require('./eitherToAsync'),
  eitherToFirst: require('./eitherToFirst'),
  eitherToLast: require('./eitherToLast'),
  eitherToMaybe: require('./eitherToMaybe'),
  eitherToResult: require('./eitherToResult'),
  firstToAsync: require('./firstToAsync'),
  firstToEither: require('./firstToEither'),
  firstToLast: require('./firstToLast'),
  firstToMaybe: require('./firstToMaybe'),
  firstToResult: require('./firstToResult'),
  lastToAsync: require('./lastToAsync'),
  lastToEither: require('./lastToEither'),
  lastToFirst: require('./lastToFirst'),
  lastToMaybe: require('./lastToMaybe'),
  lastToResult: require('./lastToResult'),
  listToArray: require('./listToArray'),
  maybeToAsync: require('./maybeToAsync'),
  maybeToEither: require('./maybeToEither'),
  maybeToFirst: require('./maybeToFirst'),
  maybeToLast: require('./maybeToLast'),
  maybeToResult: require('./maybeToResult'),
  resultToAsync: require('./resultToAsync'),
  resultToEither: require('./resultToEither'),
  resultToFirst: require('./resultToFirst'),
  resultToLast: require('./resultToLast'),
  resultToMaybe: require('./resultToMaybe')
}

module.exports = Object.assign(
  {},
  combinators,
  crocks,
  helpers,
  logic,
  monoids,
  pointfree,
  predicates,
  transforms
)
